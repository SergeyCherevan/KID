---
name: Добавление функции отрисовки изображений
overview: Добавление в класс Graphics методов для загрузки и отрисовки изображений из файлов. Рефакторинг методов расширения для работы с общим базовым классом UIElement/FrameworkElement, чтобы они работали и для Shape, и для Image.
todos:
  - id: refactor-shape-methods
    content: Рефакторинг Graphics.ShapeMethodes.cs - переделать общие методы (позиционирование, размеры, Canvas) для UIElement/FrameworkElement
    status: pending
  - id: keep-shape-color-methods
    content: Оставить методы цветов (SetStrokeColor, SetFillColor, SetColor) только для Shape в Graphics.ShapeMethodes.cs
    status: pending
    dependencies:
      - refactor-shape-methods
  - id: create-image-file
    content: Создать файл Graphics.Image.cs с основными методами Image() для загрузки и отрисовки изображений
    status: pending
  - id: add-image-overloads
    content: Добавить перегрузки методов Image() с Point и размерами
    status: pending
    dependencies:
      - create-image-file
  - id: add-image-source-method
    content: Добавить метод расширения SetSource для Image в Graphics.Image.cs
    status: pending
    dependencies:
      - create-image-file
---

# План реализации функции отрисовки изображений

## Цель

Добавить в класс `Graphics` возможность отрисовки изображений, загруженных из файлов. Создать файл `Graphics.Image.cs` со статическими методами для работы с изображениями. Рефакторинг `Graphics.ShapeMethodes.cs` для использования общего базового класса `UIElement`/`FrameworkElement`, чтобы методы расширения работали и для `Shape`, и для `Image`, и для других элементов (например, `TextBlock`).

## Анализ существующего кода

Класс `Graphics` организован как статический частичный класс, разделённый на несколько файлов:

- `Graphics.System.cs` - базовая инфраструктура (Canvas, InvokeOnUI)
- `Graphics.SimpleFigures.cs` - простые фигуры (Circle, Rectangle, Line и т.д.)
- `Graphics.Text.cs` - работа с текстом
- `Graphics.ShapeMethodes.cs` - методы расширения для фигур
- `Graphics.Color.cs` - работа с цветами

### Паттерны реализации:

1. Все методы используют `InvokeOnUI()` для работы в UI потоке
2. Методы возвращают созданный элемент или `null` при ошибке
3. Проверка `Canvas == null` перед использованием
4. Перегрузки методов с `Point` вместо `(x, y)`
5. Методы расширения следуют единому паттерну

### Архитектурное решение:

В WPF `Shape` и `Image` (а также `TextBlock`) наследуются от `FrameworkElement` (через `UIElement`). Методы позиционирования (`Canvas.SetLeft/Top`), размеры (`Width`, `Height`) и управление Canvas работают с любым `UIElement`. Поэтому общие методы расширения можно переделать для `UIElement`/`FrameworkElement`, а методы цветов (`Stroke`, `Fill`) оставить только для `Shape`.

## Реализация

### Рефакторинг: [KID/KIDLibrary/Graphics/Graphics.ShapeMethodes.cs](KID/KIDLibrary/Graphics/Graphics.ShapeMethodes.cs)

#### Переделать общие методы для UIElement/FrameworkElement:

1. **Позиционирование** - переделать для `UIElement`:
   - `SetLeftX(this UIElement element, double x)`
   - `SetTopY(this UIElement element, double y)`
   - `SetLeftTopXY(this UIElement element, double x, double y)`
   - `SetLeftTopXY(this UIElement element, Point point)`

2. **Центрирование** - переделать для `FrameworkElement` (нужен `ActualWidth`/`ActualHeight`):
   - `SetCenterX(this FrameworkElement element, double x)`
   - `SetCenterY(this FrameworkElement element, double y)`
   - `SetCenterXY(this FrameworkElement element, double x, double y)`
   - `SetCenterXY(this FrameworkElement element, Point point)`

3. **Размеры** - переделать для `FrameworkElement`:
   - `SetWidth(this FrameworkElement element, double width)`
   - `SetHeight(this FrameworkElement element, double height)`
   - `SetSize(this FrameworkElement element, double width, double height)`
   - `SetSize(this FrameworkElement element, Point size)`

4. **Управление Canvas** - переделать для `UIElement`:
   - `AddToCanvas(this UIElement element)`
   - `RemoveFromCanvas(this UIElement element)`

#### Оставить только для Shape:

1. **Цвета** - остаются только для `Shape`:
   - `SetStrokeColor(this Shape element, ColorType color)`
   - `SetFillColor(this Shape element, ColorType color)`
   - `SetColor(this Shape element, ColorType color)`

**Примечание:** После рефакторинга эти методы будут работать автоматически для `Shape`, `Image`, `TextBlock` и других элементов, наследуемых от `UIElement`/`FrameworkElement`.

### Файл: [KID/KIDLibrary/Graphics/Graphics.Image.cs](KID/KIDLibrary/Graphics/Graphics.Image.cs)

#### Основные методы Image():

1. **Image(double x, double y, string path)** - базовый метод

   - Проверка пути на null/пустоту
   - Проверка существования файла через `File.Exists()`
   - Загрузка через `BitmapImage` с обработкой ошибок
   - Создание `System.Windows.Controls.Image`
   - Позиционирование через `Canvas.SetLeft/Top`
   - Добавление на Canvas
   - Возврат `Image?`

2. **Image(Point position, string path)** - перегрузка с Point

   - Вызов базового метода с `position.X, position.Y`

3. **Image(double x, double y, string path, double width, double height)** - с размерами

   - Аналогично базовому, но с установкой `Width` и `Height`

4. **Image(Point position, string path, double width, double height)** - перегрузка

   - Вызов метода с размерами

#### Метод расширения для Image (специфичный):

1. **SetSource(this Image image, string path)** - изменение источника изображения
   - Проверка пути на null/пустоту
   - Проверка существования файла
   - Загрузка через `BitmapImage` с обработкой ошибок
   - Установка `image.Source = bitmap`
   - Возврат `Image?` для цепочки вызовов

**Примечание:** Методы позиционирования, размеров и управления Canvas будут доступны автоматически после рефакторинга `Graphics.ShapeMethodes.cs`, так как `Image` наследуется от `FrameworkElement`.

### Технические детали:

**Пространства имён:**

```csharp
using System;
using System.IO;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Media.Imaging;
```

**Загрузка изображения:**

```csharp
var bitmap = new BitmapImage();
bitmap.BeginInit();
bitmap.UriSource = new Uri(path, UriKind.RelativeOrAbsolute);
bitmap.CacheOption = BitmapCacheOption.OnLoad;
bitmap.EndInit();
image.Source = bitmap;
```

**Обработка ошибок:**

- Try-catch при загрузке BitmapImage
- Проверка существования файла
- Возврат `null` при любой ошибке (как в других методах)

**Паттерн методов расширения:**

- Использование `InvokeOnUI` для работы в UI потоке
- Проверка `Canvas == null`
- Возврат соответствующего типа для цепочки вызовов
- Для общих методов - использование `UIElement`/`FrameworkElement` как базового типа

## Структура файлов

### Graphics.ShapeMethodes.cs (после рефакторинга):

```csharp
namespace KID
{
    public static partial class Graphics
    {
        // Общие методы для UIElement/FrameworkElement
        public static UIElement? SetLeftX(this UIElement element, double x) { ... }
        public static UIElement? SetTopY(this UIElement element, double y) { ... }
        public static UIElement? SetLeftTopXY(this UIElement element, double x, double y) { ... }
        public static UIElement? SetLeftTopXY(this UIElement element, Point point) { ... }
        
        public static FrameworkElement? SetCenterX(this FrameworkElement element, double x) { ... }
        public static FrameworkElement? SetCenterY(this FrameworkElement element, double y) { ... }
        public static FrameworkElement? SetCenterXY(this FrameworkElement element, double x, double y) { ... }
        public static FrameworkElement? SetCenterXY(this FrameworkElement element, Point point) { ... }
        
        public static FrameworkElement? SetWidth(this FrameworkElement element, double width) { ... }
        public static FrameworkElement? SetHeight(this FrameworkElement element, double height) { ... }
        public static FrameworkElement? SetSize(this FrameworkElement element, double width, double height) { ... }
        public static FrameworkElement? SetSize(this FrameworkElement element, Point size) { ... }
        
        public static UIElement? AddToCanvas(this UIElement element) { ... }
        public static UIElement? RemoveFromCanvas(this UIElement element) { ... }
        
        // Методы только для Shape
        public static Shape? SetStrokeColor(this Shape element, ColorType color) { ... }
        public static Shape? SetFillColor(this Shape element, ColorType color) { ... }
        public static Shape? SetColor(this Shape element, ColorType color) { ... }
    }
}
```

### Graphics.Image.cs:

```csharp
namespace KID
{
    public static partial class Graphics
    {
        // Основные методы Image()
        public static Image? Image(double x, double y, string path) { ... }
        public static Image? Image(Point position, string path) { ... }
        public static Image? Image(double x, double y, string path, double width, double height) { ... }
        public static Image? Image(Point position, string path, double width, double height) { ... }
        
        // Специфичный метод расширения для Image
        public static Image? SetSource(this Image image, string path) { ... }
    }
}
```

## Порядок выполнения

1. Рефакторинг `Graphics.ShapeMethodes.cs`:
   - Переделать общие методы для `UIElement`/`FrameworkElement`
   - Оставить методы цветов только для `Shape`
   - Проверить, что существующий код продолжает работать

2. Создать файл `Graphics.Image.cs` с основными методами `Image()`
3. Добавить метод расширения `SetSource` для `Image`
4. Проверить, что методы расширения из рефакторинга работают с `Image`
5. Проверить соответствие стилю кода и паттернам существующих методов
6. Обновить документацию (опционально)

## Преимущества рефакторинга

- Единый набор методов расширения для всех элементов (`Shape`, `Image`, `TextBlock` и др.)
- Меньше дублирования кода
- Более универсальный API
- Методы цветов остаются специфичными для `Shape`, где они имеют смысл

## Поддерживаемые форматы

WPF поддерживает: PNG, JPG, BMP, GIF, TIFF, ICO и другие форматы через BitmapImage.