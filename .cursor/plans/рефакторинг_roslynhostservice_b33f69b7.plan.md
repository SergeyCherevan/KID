---
name: Рефакторинг RoslynHostService
overview: "Анализ нарушений принципов проектирования в логике подключения сборок и импортов в RoslynHostService и план рефакторинга: вынос набора ссылок в отдельный компонент, устранение дублирования и магических строк, улучшение тестируемости и расширяемости."
todos: []
isProject: false
---

# План рефакторинга конфигурации ссылок RoslynHostService

## 1. Анализ текущего кода

Фрагмент в [RoslynHostService.cs](KID.WPF.IDE/Services/CodeEditor/RoslynHostService.cs) (строки 31–59) делает следующее:

- Собирает список сборок для Roslyn: рантайм (System.Runtime, object, Enumerable), KID.Library, NAudio, WPF (по имени и по типу с резервом).
- Фильтрует сборки по непустому `Assembly.Location` (локальная функция `LoadIfHasLocation` и проверки для `UIElement`/`Brush`).
- Формирует `typeNamespaceImports` для глобальных usings.
- Передаёт результат в `RoslynHostReferences.NamespaceDefault.With(...)` и затем в конструктор `RoslynHost`.

---

## 2. Нарушенные принципы проектирования

### 2.1. Single Responsibility (SRP)

**Нарушение:** Один класс одновременно:

- определяет, *какие* сборки и типы нужны IDE KID;
- знает *как* их загружать (по имени vs по типу, проверка `Location`);
- знает детали RoslynPad (MEF, `additionalAssemblies`, что не добавлять `RoslynHost.Assembly`);
- создаёт и кэширует `RoslynHost`.

**Следствие:** Изменение набора ссылок, способа загрузки или логики RoslynHost смешано в одном месте, сложнее тестировать и расширять.

### 2.2. Open/Closed (OCP)

**Нарушение:** Добавление новой сборки или нового импорта требует правки самого `RoslynHostService` (новые строки в списках, новые условия). Нет расширения через конфигурацию или отдельный компонент без изменения класса.

### 2.3. Дублирование и магические строки

**Нарушение:**

- Имена сборок заданы строками: `"System.Runtime"`, `"PresentationFramework"`, `"RoslynPad.Roslyn.Windows"` и т.д.
- Одна и та же логическая группа (WPF) представлена двумя способами: загрузка по имени + резерв через `typeof(UIElement).Assembly` / `typeof(Brush).Assembly`, с ручной проверкой `Contains` и `Location`.
- Список «что нужно для IntelliSense» размазан: часть в `assemblyList`, часть в `typeNamespaceImports`, часть в `additionalAssemblies` конструктора.

### 2.4. Зависимость от деталей реализации и окружения

**Нарушение:**

- Прямая зависимость от того, что `MetadataReference.CreateFromFile` требует непустой `Location` (знание внутренностей RoslynHostReferences).
- Жёсткое знание про MEF и дублирование экспорта (комментарий про `DocumentationProviderService`).
- Смешение уровней абстракции: низкоуровневые вызовы `Assembly.Load` и проверки `Location` в одном методе с высокоуровневой сборкой `RoslynHost`.

### 2.5. Тестируемость

**Наружение:** Невозможно проверить «правильный ли набор сборок/импортов» без создания реального `RoslynHost` и без реальной загрузки сборок. Нет точки подстановки стратегии или конфигурации.

---

## 3. Варианты решения

### Вариант A: Провайдер набора ссылок (рекомендуется)

**Идея:** Вынести «набор сборок и импортов для KID IDE» в отдельный компонент.

- Ввести интерфейс, например `IRoslynReferenceProvider`, с методом, возвращающим готовый набор данных (например, коллекции сборок и типов для импортов).
- Реализация, например `KidIdeRoslynReferenceProvider`: содержит всю текущую логику (рантайм, WPF, KID.Library, NAudio, фильтрацию по `Location`, резерв по типам).
- `RoslynHostService` только: получает от провайдера сборки и типы для импортов, вызывает `RoslynHostReferences.NamespaceDefault.With(...)`, создаёт `RoslynHost` с фиксированными `additionalAssemblies` для RoslynPad, кэширует хост.

**Плюсы:** Чёткое разделение ответственности, набор ссылок можно тестировать и подменять (другая реализация провайдера для тестов или другой редакции набора).  
**Минусы:** Появляется новый тип и регистрация в DI.

### Вариант B: Конфигурация + фабрика ссылок

**Идея:** Описать набор ссылок данными (константы или конфиг: имена сборок, типы для импортов), а загрузку и фильтрацию вынести в маленький хелпер/фабрику.

- Класс конфигурации (или статические списки) с именами сборок и типами для `typeNamespaceImports`.
- Отдельный метод/класс «собрать `List<Assembly>` из конфига» с правилом: попытка по имени, при пустом `Location` — резерв по типу из запасного списка.
- `RoslynHostService` строит ссылки из конфига через эту фабрику и создаёт хост.

**Плюсы:** Добавление новой сборки = добавление строки в конфиг/константы, без размазывания логики.  
**Минусы:** Связь «имя сборки ↔ запасной тип» всё равно нужно где-то хранить; конфиг может усложниться при росте числа правил.

### Вариант C: Внутренний рефакторинг без новых публичных типов

**Идея:** Оставить публичный контракт `IRoslynHostService` и один класс, но разбить `GetHost()` на приватные методы и убрать дублирование.

- Методы вида: `GetRuntimeAssemblies()`, `GetWpfAssemblies()` (с LoadIfHasLocation и резервом по типам), `GetTypeNamespaceImports()`, `EnsureAssemblyWithLocation(Assembly?)` (или аналог).
- В `GetHost()` — вызов этих методов, объединение списков, вызов `With(...)` и конструктора `RoslynHost`.

**Плюсы:** Минимум изменений снаружи, улучшение читаемости и SRP внутри класса.  
**Минусы:** OCP и тестируемость улучшаются слабо, знание деталей Roslyn остаётся в том же классе.

---

## 4. Рекомендуемое направление: Вариант A с элементами B

- Ввести **провайдер набора ссылок** (интерфейс + реализация), чтобы `RoslynHostService` не знал о деталях «какие сборки и импорты нужны KID».
- Внутри провайдера использовать **структурированный перечень** (имена сборок + типы для импортов + резервные типы для WPF), чтобы убрать магические строки в одну «схему» и упростить добавление новых пунктов (элемент подхода B).
- Оставить в `RoslynHostService` только: получение данных от провайдера, формирование `RoslynHostReferences`, создание и кэширование `RoslynHost`, знание о фиксированных `additionalAssemblies` для RoslynPad и о том, что не нужно добавлять сборку RoslynHost (MEF).

Так достигаются:

- **SRP:** «Что нужно для редактора» — у провайдера; «как создать и кэшировать хост» — у сервиса.
- **OCP:** Новые сборки/импорты добавляются в провайдер или в его конфигурацию, без правки логики создания хоста.
- **Меньше дублирования:** Один источник правды для списка сборок и импортов, централизованная логика «загрузка по имени + резерв по типу».
- **Тестируемость:** Провайдер можно тестировать отдельно (возвращаемые сборки и типы); при необходимости можно подменить провайдер в тестах хоста.

---

## 4a. Источник данных: те же сборки, что и при выполнении кода (без seed-типов)

При выполнении пользовательского кода [CSharpCompiler](KID.WPF.IDE/Services/CodeExecution/CSharpCompiler.cs) уже использует **все загруженные в домен сборки**:

```csharp
var references = AppDomain.CurrentDomain.GetAssemblies()
    .Where(a => !a.IsDynamic && !string.IsNullOrEmpty(a.Location))
    ...
```

То есть программа в момент выполнения действительно «знает» все сборки, доступные для компиляции и запуска. Seed-типы не обязательны: провайдер может брать тот же источник.

**GetAssemblies():** вызывать `AppDomain.CurrentDomain.GetAssemblies()` и применять тот же фильтр: `!a.IsDynamic && !string.IsNullOrEmpty(a.Location)`. Исключить при необходимости только сборки, которые не должны попадать в ссылки скрипта (например, служебные RoslynPad для MEF — если они не нужны в проекте документа; при сомнении оставить как у компилятора). Итог: один источник правды с [CodeExecution](KID.WPF.IDE/Services/CodeExecution/CSharpCompiler.cs), без дублирования списков и без набора seed-типов.

**GetTypeNamespaceImports():** получать типы для глобальных usings из **этих же сборок** через рефлексию: для каждой сборки из списка выше — `GetExportedTypes()` (или `GetTypes()` с фильтром), сгруппировать по `Type.Namespace`, взять по одному типу на пространство имён и вернуть. В результате список импортов выводится из реально загруженных сборок, без жёстко заданных seed-типов. При желании потом можно ограничить набор неймспейсов (например, только `System*`, `KID`, `NAudio`) для уменьшения числа глобальных usings.

---

## 5. Конкретные задачи (при выборе Варианта A)

1. **Интерфейс провайдера**
  - Файл: `KID.WPF.IDE/Services/CodeEditor/Interfaces/IRoslynReferenceProvider.cs`  
  - Метод(ы): два отдельных метода — `IReadOnlyList<Assembly> GetAssemblies()` и `IReadOnlyList<Type> GetTypeNamespaceImports()`.  
  - XML: «предоставляет набор сборок и типов для глобальных импортов, используемых RoslynHost в KID IDE».
2. **Реализация провайдера (данные из рефлексии, без seed-типов)**
  - Файл: `KID.WPF.IDE/Services/CodeEditor/KidIdeRoslynReferenceProvider.cs`  
  - **GetAssemblies():** как в CSharpCompiler — `AppDomain.CurrentDomain.GetAssemblies()` с фильтром `!IsDynamic && !string.IsNullOrEmpty(Location)`. При необходимости отфильтровать по имени сборки (например, не отдавать сборки RoslynPad.* в ссылки документа — уточнить по поведению).  
  - **GetTypeNamespaceImports():** по списку сборок из GetAssemblies() обойти каждую сборку, получить экспортируемые типы, сгруппировать по `Namespace`, выбрать по одному типу на пространство имён; вернуть список типов. Опционально: фильтр по префиксу неймспейса, чтобы не добавлять десятки лишних usings.  
  - Никакого жёсткого перечня seed-типов или имён сборок — только рефлексия над текущим доменом и полученными сборками.
3. **Упрощение RoslynHostService**
  - Зависимость: `IRoslynReferenceProvider`.  
  - В `GetHost()`: вызвать провайдер, получить сборки и типы; вызвать `RoslynHostReferences.NamespaceDefault.With(assemblyReferences: ..., typeNamespaceImports: ...)`; создать `RoslynHost(additionalAssemblies: [...], references: ...)`; кэшировать и вернуть.  
  - Удалить из класса всю логику выбора и загрузки сборок и формирования импортов; оставить только комментарий о том, почему не добавляется сборка RoslynHost (MEF).
4. **Регистрация в DI**
  - В [ServiceCollectionExtensions.cs](KID.WPF.IDE/Services/DI/ServiceCollectionExtensions.cs): зарегистрировать `IRoslynReferenceProvider` → `KidIdeRoslynReferenceProvider` (Singleton или Transient в зависимости от того, должен ли провайдер иметь состояние).  
  - Зарегистрировать `RoslynHostService` как раньше; он получит `IRoslynReferenceProvider` через конструктор.
5. **Документация**
  - Обновить [docs/SUBSYSTEMS.md](docs/SUBSYSTEMS.md) (раздел про RoslynHostService): указать, что набор ссылок определяется `IRoslynReferenceProvider`, реализация — `KidIdeRoslynReferenceProvider`.  
  - При необходимости кратко обновить [docs/ARCHITECTURE.md](docs/ARCHITECTURE.md), чтобы отразить зависимость RoslynHostService от провайдера.
6. **Тестирование**
  - Ручная проверка: запуск IDE, открытие файла с Graphics и т.д., убедиться, что IntelliSense и подсветка работают как до рефакторинга.  
  - По желанию: unit-тест для провайдера (возвращаемые сборки не пусты, содержатся ожидаемые имена/типы).

---

## 6. Порядок выполнения

1. Добавить `IRoslynReferenceProvider` и реализацию `KidIdeRoslynReferenceProvider` с переносом логики и структурированием списков.
2. Изменить `RoslynHostService`: зависимость от провайдера, упрощённый `GetHost()`.
3. Зарегистрировать провайдер в DI.
4. Обновить документацию.
5. Ручная проверка (и при необходимости — тест провайдера).

---

## 7. Оценка сложности


| Задача                            | Сложность | Время     | Риски                                                   |
| --------------------------------- | --------- | --------- | ------------------------------------------------------- |
| Интерфейс + реализация провайдера | Средняя   | 30–45 мин | Аккуратно перенести все кейсы (WPF fallback, Location). |
| Упрощение RoslynHostService       | Низкая    | 15–20 мин | Не сломать кэширование и вызов RoslynHost.              |
| DI и документация                 | Низкая    | 10–15 мин | —                                                       |
| Проверка                          | Низкая    | 10–15 мин | Регрессия набора ссылок при переносе.                   |


**Итог:** рефакторинг средней сложности, основное — аккуратный перенос логики в провайдер и сохранение текущего поведения.