# Console API

## Обзор

Console API предоставляет стандартный интерфейс для консольного ввода и вывода в пользовательском коде. Все операции с консолью автоматически перенаправляются в панель консольного вывода приложения .KID.

## Вывод данных

### Console.WriteLine()

Выводит строку с переводом строки в конец консоли.

**Синтаксис:**
```csharp
Console.WriteLine();
Console.WriteLine(string value);
Console.WriteLine(object value);
Console.WriteLine(string format, params object[] args);
```

**Примеры:**
```csharp
Console.WriteLine("Привет, мир!");
Console.WriteLine(42);
Console.WriteLine("Число: {0}", 10);
Console.WriteLine("Имя: {0}, Возраст: {1}", "Иван", 25);
```

**Особенности:**
- Текст автоматически добавляется в конец консоли
- Консоль автоматически прокручивается к новому тексту
- Поддерживается форматирование строк через `string.Format()`
- При длинных строках доступна горизонтальная прокрутка (строки не переносятся автоматически)

### Console.Write()

Выводит строку без перевода строки.

**Синтаксис:**
```csharp
Console.Write(string value);
Console.Write(object value);
Console.Write(string format, params object[] args);
```

**Примеры:**
```csharp
Console.Write("Введите имя: ");
string name = Console.ReadLine();

Console.Write("Число: ");
Console.Write(42);
```

**Особенности:**
- Текст добавляется без перевода строки
- Можно использовать для вывода на одной строке

### Console.Out

Свойство для получения `TextWriter` для вывода.

**Пример:**
```csharp
Console.Out.WriteLine("Вывод через Out");
```

## Ввод данных

### Console.ReadLine()

Читает строку из консоли до нажатия Enter.

**Синтаксис:**
```csharp
string? ReadLine();
```

**Примеры:**
```csharp
Console.Write("Введите ваше имя: ");
string name = Console.ReadLine();
Console.WriteLine($"Привет, {name}!");

Console.Write("Введите число: ");
string input = Console.ReadLine();
int number = int.Parse(input);
Console.WriteLine($"Вы ввели: {number}");
```

**Особенности:**
- Блокирует выполнение программы до ввода строки
- Возвращает `null`, если ввод был отменен
- Поддерживает кириллицу и Unicode символы
- Поддерживает Backspace для удаления символов
- Автоматически устанавливает фокус на консоль при вызове

### Console.Read()

Читает один символ из консоли.

**Синтаксис:**
```csharp
int Read();
```

**Примеры:**
```csharp
Console.Write("Нажмите любую клавишу: ");
int key = Console.Read();
char character = (char)key;
Console.WriteLine($"\nВы нажали: {character}");
```

**Особенности:**
- Блокирует выполнение программы до ввода символа
- Возвращает код символа (int)
- Поддерживает кириллицу и Unicode символы
- Автоматически устанавливает фокус на консоль при вызове

### Console.In

Свойство для получения `TextReader` для ввода.

**Пример:**
```csharp
string? line = Console.In.ReadLine();
```

## Очистка консоли

### Console.Clear()

Очищает содержимое консоли.

**Синтаксис:**
```csharp
Console.Clear();
```

**Пример:**
```csharp
Console.WriteLine("Этот текст будет удален");
Console.Clear();
Console.WriteLine("Консоль очищена!");
```

**Особенности:**
- Автоматически заменяется компилятором на `TextBoxConsole.StaticConsole.Clear()`
- Работает как стандартный `Console.Clear()` в пользовательском коде
- Полностью очищает содержимое панели консоли

## Вывод ошибок

### Console.Error

Свойство для получения `TextWriter` для вывода ошибок.

**Пример:**
```csharp
Console.Error.WriteLine("Произошла ошибка!");
```

**Особенности:**
- В текущей реализации использует тот же поток, что и `Console.Out`
- Ошибки выводятся в ту же панель консоли

## Примеры использования

### Простой ввод/вывод

```csharp
Console.WriteLine("Добро пожаловать в .KID!");
Console.Write("Введите ваше имя: ");
string name = Console.ReadLine();
Console.WriteLine($"Привет, {name}!");
```

### Ввод чисел

```csharp
Console.Write("Введите первое число: ");
int a = int.Parse(Console.ReadLine());

Console.Write("Введите второе число: ");
int b = int.Parse(Console.ReadLine());

int sum = a + b;
Console.WriteLine($"Сумма: {sum}");
```

### Цикл с вводом

```csharp
while (true)
{
    Console.Write("Введите команду (exit для выхода): ");
    string command = Console.ReadLine();
    
    if (command == "exit")
        break;
    
    Console.WriteLine($"Выполняю команду: {command}");
}
```

### Форматированный вывод

```csharp
string name = "Иван";
int age = 25;
double height = 175.5;

Console.WriteLine("Имя: {0}, Возраст: {1}, Рост: {2:F1} см", name, age, height);
// Вывод: Имя: Иван, Возраст: 25, Рост: 175.5 см
```

### Очистка и обновление

```csharp
for (int i = 10; i >= 0; i--)
{
    Console.Clear();
    Console.WriteLine($"Обратный отсчет: {i}");
    System.Threading.Thread.Sleep(1000);
}
Console.WriteLine("Время вышло!");
```

## Особенности реализации

### Потокобезопасность

- Все операции с консолью выполняются в UI потоке через `DispatcherManager`
- Ввод и вывод безопасны для использования из любого потока

### Поддержка Unicode

- Полная поддержка кириллицы и других Unicode символов
- Кодировка: UTF-8

### Блокирующий ввод

- `Console.ReadLine()` и `Console.Read()` блокируют выполнение программы
- Программа ожидает ввода пользователя
- Консоль автоматически получает фокус при вызове методов ввода

### Обработка клавиш

- **Enter** — завершает ввод строки в `ReadLine()`
- **Backspace** — удаляет последний символ при вводе
- **Пробел** — обрабатывается как обычный символ

### Автоматическая замена Console.Clear()

Компилятор автоматически заменяет вызовы `Console.Clear()` на `TextBoxConsole.StaticConsole.Clear()` для корректной работы в контексте приложения.

## Ограничения

- Консоль не поддерживает изменение цвета текста (всегда используется цвет из темы оформления)
- Нет поддержки изменения позиции курсора (текст всегда добавляется в конец)
- Нет поддержки чтения без отображения (для паролей)
- `Console.Error` в текущей реализации использует тот же поток, что и `Console.Out`

## Архитектура и паттерны (реализация модуля Console)

Этот раздел описывает, какие паттерны проектирования и архитектурные решения используются в реализации Console API внутри .KID.

### Общая архитектурная идея

Модуль консоли в .KID — это адаптер “`System.Console` → WPF `TextBox`”, встроенный в общий пайплайн выполнения пользовательского кода через **контекст выполнения** и **централизованную синхронизацию UI-потока**.

Ключевые узлы:
- Абстракция консоли через `IConsole` (чтобы реализацию можно было менять/расширять)
- Контекст `IConsoleContext`, который на время запуска переназначает `Console.Out/In/Error` и затем восстанавливает обратно
- Все операции с UI выполняются через `DispatcherManager`
- `Console.Clear()` у пользователя работает благодаря реврайту кода на этапе компиляции (замена вызова на внутренний `TextBoxConsole.StaticConsole.Clear()`)

### Реализованные паттерны проектирования

### 1) Adapter (Адаптер)

- `TextBoxConsole` адаптирует WPF `TextBox` под консольный интерфейс, реализуя `IConsole`.
- Совместимость со стандартным API `System.Console` достигается через адаптеры потоков:
  - `TextBoxTextWriter : TextWriter` — вывод
  - `TextBoxTextReader : TextReader` — ввод

Таким образом, `Console.SetOut(...)`, `Console.SetIn(...)`, `Console.SetError(...)` могут работать с “консолью на базе TextBox” как с обычными потоками.

### 2) Proxy / UI-thread marshalling (Прокси для UI-потока)

`DispatcherManager` выступает как прокси-исполнитель: внешний вызов “проксируется” в UI-поток (через `BeginInvoke/Invoke`), чтобы `TextBoxConsole` мог безопасно обновлять UI из фонового потока (где исполняется пользовательский код).

### 3) Observer (Наблюдатель)

`TextBoxConsole` публикует событие `OutputReceived`: на него можно подписаться, чтобы отслеживать вывод (например, для логирования или дополнительной реакции UI).

### 4) Facade + Service Locator (Фасад + глобальная точка доступа)

`TextBoxConsole.StaticConsole` — статический фасад над “текущим” экземпляром `TextBoxConsole`, чтобы иметь возможность вызывать `Clear()` без передачи ссылки на объект.

Это также похоже на Service Locator (хранение текущей реализации в статическом поле) — осознанный компромисс ради прозрачной поддержки `Console.Clear()` в пользовательском коде.

### 5) Context + RAII/Dispose (Контекст выполнения и управление жизненным циклом)

`TextBoxConsoleContext` реализует паттерн “контекст выполнения”:
- при `Init()` сохраняет оригинальные `Console.Out/In/Error`
- подменяет их на потоки `TextBoxConsole`
- при `Dispose()` восстанавливает оригинальные потоки

Это обеспечивает предсказуемый жизненный цикл и отсутствие “утечек” переназначенных потоков между запусками.

### 6) Compiler rewriting / “AOP-like” (сквозная функциональность на этапе компиляции)

В `CSharpCompiler` используется `ConsoleClearRewriter` (на базе Roslyn `CSharpSyntaxRewriter`), который заменяет:
- `Console.Clear()`
- `System.Console.Clear()`

на вызов:
- `KID.Services.CodeExecution.TextBoxConsole.StaticConsole.Clear()`

Именно поэтому `Console.Clear()` корректно очищает панель консоли приложения, даже если пользовательский код использует стандартный API.

### Архитектурные особенности реализации

- **Слои и разделение ответственности**
  - Реализация консоли живёт в слое сервисов: `KID.WPF.IDE/Services/CodeExecution/*` (`TextBoxConsole`, `TextBoxConsoleContext`)
  - Общая синхронизация UI вынесена в библиотечный слой: `KID.Library/DispatcherManager.cs`

- **Потоковая модель и потокобезопасность**
  - Пользовательский код исполняется в фоне, но любые операции с UI выполняются через `DispatcherManager`
  - Ввод реализован блокирующим образом, с синхронизацией через `AutoResetEvent` и защитой `lock`-ом (чтобы `Read()`/`ReadLine()` не пересекались)

- **Event-driven ввод**
  - Символы приходят из WPF событий `PreviewKeyDown/PreviewTextInput`, а поток выполнения ждёт пользовательский ввод через событие синхронизации

- **Расширяемость**
  - Можно добавить альтернативную консоль (например, `RichTextBox`/отдельное окно/сетевую), реализовав `IConsole` и/или `IConsoleContext`, не ломая общий пайплайн выполнения.

### Алгоритм работы `Read()` и `ReadLine()` (подробно)

Ниже — подробный разбор того, как устроены `Read()` и `ReadLine()` в текущей реализации `TextBoxConsole`, включая взаимодействие потоков, UI-событий WPF и синхронизацию.

#### Общая схема ввода

Ввод реализован как связка **“UI-события WPF → буфер одного символа → сигнал → блокирующее чтение”**.

Ключевые примитивы и поля:
- `isReading` — флаг “сейчас ждём ввод”. Обработчики клавиатуры игнорируют события, если он выключен.
- `lastReadChar` — буфер **одного** последнего введённого символа (или спец-символа `\n`, `\b`).
- `keyDownReadEvent` (`AutoResetEvent`) — “будильник” для потока, который вызвал `Read()`/`ReadLine()` и ждёт ввода.
- `readLock` — защищает ввод от параллельных чтений (чтобы `Read()`/`ReadLine()` не пересекались).

Общий принцип:
- поток выполнения (обычно фоновый) вызывает `Read()`/`ReadLine()` и блокируется на `keyDownReadEvent.WaitOne()`
- UI-поток ловит нажатия в `PreviewKeyDown/PreviewTextInput`, пишет символ в `lastReadChar`, вызывает `keyDownReadEvent.Set()`
- поток выполнения просыпается, забирает `lastReadChar` и вручную “эхо-выводит” символ в `TextBox` (поскольку `e.Handled = true` подавляет стандартный ввод WPF)

#### Как формируется символ: обработчики клавиатуры

Символы поступают через два обработчика:
- `PreviewTextInput` — обычный текстовый ввод (включая кириллицу/Unicode)
- `PreviewKeyDown` — специальные клавиши (Enter/Backspace/Space)

Алгоритм обработчиков:
- если `isReading == false` → `return`
- записать символ в `lastReadChar`
- вызвать `keyDownReadEvent.Set()` (разбудить `WaitOne()`)
- установить `e.Handled = true`, чтобы WPF сам не менял текст `TextBox` (всё отображение делается вручную)

#### Алгоритм `Read()` (чтение одного символа)

`Read()` возвращает код одного символа (как `System.Console.Read()`).

Пошагово:
1. `lock (readLock)` — эксклюзивно захватываем ввод (параллельные чтения запрещены).
2. `isReading = true` — включаем режим ожидания ввода.
3. В UI-потоке:
   - `textBox.IsReadOnly = false` (разрешаем ввод),
   - `FocusTextBox()` (фокус/курсор в конец/прокрутка).
4. `keyDownReadEvent.WaitOne()` — блокируем поток до тех пор, пока UI не вызовет `Set()`.
5. После пробуждения:
   - `isReading = false`,
   - `result = (char)lastReadChar`.
6. В UI-потоке вручную “эхо-выводим” символ:
   - `AppendText(result.ToString())`, прокрутка, курсор в конец,
   - `textBox.IsReadOnly = true` (снова блокируем ввод).
7. `lastReadChar = -1` (сбрасываем буфер) и возвращаем `(int)result`.

Практические последствия:
- В `TextBox` появляется **ровно один** символ ввода (или `\n`/`\b`, если это Enter/Backspace).

#### Алгоритм `ReadLine()` (чтение строки до Enter)

`ReadLine()` читает последовательность символов до Enter и возвращает строку **без символа перевода строки**.

Пошагово:
1. `lock (readLock)` — эксклюзивно захватываем ввод.
2. Создаём `StringBuilder result` — буфер собираемой строки.
3. `isReading = true` — включаем режим ожидания ввода.
4. В UI-потоке: `IsReadOnly = false`, `FocusTextBox()`.
5. Цикл чтения:
   - `WaitOne()` — блокируемся до следующего символа,
   - `StopManager.StopIfButtonPressed()` — проверяем отмену (между символами, после пробуждения),
   - `symbol = (char)lastReadChar; lastReadChar = -1`.
6. Разбор `symbol`:
   - если `symbol == '\b'` (Backspace):
     - если в `result` есть символы, то:
       - в UI удаляется последний символ текста `TextBox` (через `Substring(0, len - 1)`),
       - из `result` удаляется последний символ,
     - если `result` пустой — Backspace игнорируется (нельзя стереть “старый вывод” консоли).
   - иначе (обычный символ или Enter):
     - в UI делается `AppendText(symbol.ToString())` (эхо),
     - если `symbol != '\n'`, добавляем символ в `result`.
7. Цикл завершается при `symbol == '\n'` (Enter).
8. `isReading = false`, `textBox.IsReadOnly = true`, возвращаем `result.ToString()`.

#### Нюансы и ограничения текущей реализации

- **Буфер на один символ**: `lastReadChar` хранит только последний символ. Это упрощает синхронизацию, но не является полноценной очередью ввода.
- **`AutoResetEvent` будит одного ждателя**: это соответствует модели “одно активное чтение”, которую дополнительно гарантирует `readLock`.
- **Эхо делается вручную**: курсор всегда принудительно ставится в конец, редактирование “в середине строки” не поддерживается.
- **Параллельный вывод во время ввода**: если в момент набора кто-то печатает в консоль (`Write()`), возможны рассинхронизации — например, Backspace удаляет последний символ всего `TextBox`, который может оказаться не тем, что лежит в `result`.

## См. также

- [Архитектура проекта](ARCHITECTURE.md) — общая информация о структуре проекта
- [Подсистемы](SUBSYSTEMS.md) — подробное описание подсистемы консольного ввода/вывода
- [Функциональность](FEATURES.md) — обзор возможностей приложения
